---
title: 'Agensight Tracing: Init, Trace, and Span'
description: 'How to initialize Agensight tracing and use the @trace and @span decorators.'
---

# Agensight Tracing Essentials

This guide focuses on the core components for instrumenting your Python code with Agensight: initializing the tracer, creating traces, and adding spans.

## Initialization: `setup_tracing`

Before creating any traces or spans, you must initialize the Agensight tracing system. This is typically done once when your application starts. The primary function for this is `setup_tracing`.

*   **Purpose**: Configures the OpenTelemetry TracerProvider and sets up an exporter to determine where trace data is sent.
*   **Key Parameters**:
    *   `service_name` (str, optional): The name of your application or service (e.g., "my-api"). Defaults to `"default"`.
    *   `exporter_type` (str, optional): Specifies the trace destination.
        *   If `None` (default): Uses the `TRACE_EXPORTER` environment variable, or defaults to `"console"` (prints traces to standard output).
        *   `"db"`: Stores traces in a local SQLite database (`traces.db`).
        *   Other values like `"otlp"`, `"zipkin"`, `"jaeger"` can be used for other standard OpenTelemetry backends.

**Relevant File:** `agensight/tracing/setup.py`

**Basic Usage Example:**

```python
from agensight.tracing import setup_tracing

# Initialize tracing, sending data to the console for "my-application"
setup_tracing(service_name="my-application", exporter_type="console")

# To use the database exporter (ensure TRACE_EXPORTER=db is set in env, or pass explicitly):
# setup_tracing(service_name="my-data-service", exporter_type="db")
```

## Creating Traces with `@trace`

The `@trace` decorator defines the boundaries of a complete operation or request. Each call to a function decorated with `@trace` initiates a new, independent trace.

**Relevant File:** `agensight/tracing/decorators.py`

### Syntax: `@trace(name: Optional[str] = None, **default_attributes)`

*   **`name` (str, optional)**: Sets a custom name for this trace. If omitted, the decorated function's name (`func.__name__`) is used.
*   **`**default_attributes` (dict, optional)**: Key-value pairs to be stored as metadata for the trace. This is particularly relevant if you are using the `"db"` exporter, as these attributes are saved in the `metadata` column of the `traces` table.

**How it Works:**
When the decorated function is invoked:
1. A unique `trace_id` is generated.
2. The function's execution is timed (start and end).
3. If using the `"db"` exporter, trace details (ID, name, times, session ID if active, and `default_attributes`) are recorded in the `traces` database table.
4. Context variables (`current_trace_id`, `current_trace_name`) are set, allowing any `@span` decorators used within this function's call stack to automatically associate with this parent trace.

**Usage Example:**

```python
from agensight.tracing import trace, setup_tracing

setup_tracing(service_name="order-processor") # Default exporter: console

@trace(name="process_customer_order", customer_tier="gold")
def process_order(order_id: str, items: list):
    print(f"Processing order {order_id} with {len(items)} items.")
    # ... main order processing logic ...
    # This logic might call other functions, some of which could be decorated with @span
    # e.g., check_inventory(items)
    # e.g., charge_customer(order_id)
    print(f"Order {order_id} processed successfully.")
    return {"status": "success", "order_id": order_id}

process_order("ORD12345", [{"item_id": "A1", "qty": 2}, {"item_id": "B2", "qty": 1}])
```

## Creating Spans with `@span`

Spans represent individual units of work or specific operations *within* an active trace. Use the `@span` decorator to instrument functions that perform these granular tasks. A `@span`-decorated function should typically be called by a function that is already part of a trace (i.e., decorated with `@trace` or another `@span`).

**Relevant File:** `agensight/tracing/decorators.py`

### Syntax: `@span(name: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None, input: Optional[Any] = None, output: Optional[Any] = None)`

*   **`name` (str, optional)**: A custom name for this specific operation/span. If omitted, the decorated function's name is used.
*   **`metadata` (Dict[str, Any], optional)**: A dictionary of custom key-value attributes to add to this span, providing detailed context.
*   **`input` (Any, optional)**: Explicitly provide the input data relevant to this span's operation.
*   **`output` (Any, optional)**: Explicitly provide the output data from this span's operation.

**How it Works:**
When a `@span`-decorated function is called:
1. It links to the `current_trace_id` established by its parent `@trace` (or another parent `@span`).
2. It records its own `span_name`, any provided `metadata`, and its execution time.
3. It attempts to automatically capture input/output:
    *   Input: Prefers explicitly set `trace_input` (via `agensight.tracing.context`), then the `input` argument to `@span`, then the function's arguments (`*args`, `**kwargs`).
    *   Output: Prefers the `output` argument to `@span`, then the function's return value.
4.  Captured I/O is normalized (especially for AI/LLM interactions) and stored as a `gen_ai.normalized_input_output` attribute on the span.
5.  It attempts to extract LLM token usage details (e.g., `total_tokens`, `prompt_tokens`) from the function's result if the result has a `usage` attribute or is a dictionary with a "usage" key. These are added as span attributes (e.g., `llm.usage.total_tokens`).
6.  If an error occurs, the span's status is marked as `ERROR`.

**Usage Example (within a traced function):**

```python
from agensight.tracing import trace, span, setup_tracing
import time

setup_tracing(service_name="order-processor")

@span(name="inventory_check_step", metadata={"criticality": "high"})
def check_inventory(items_to_check: list):
    print(f"Checking inventory for {len(items_to_check)} types of items...")
    # Simulate database call or external service
    time.sleep(0.2)
    availability = {item.get("item_id"): True for item in items_to_check} # Simplified
    print("Inventory check complete.")
    return availability

# Assume this function simulates an LLM call for fraud detection
def analyze_for_fraud(order_details: dict) -> dict:
    time.sleep(0.3) # Simulate LLM call
    return {
        "fraud_score": 0.1,
        "assessment": "low_risk",
        "usage": {"prompt_tokens": 100, "completion_tokens": 10, "total_tokens": 110}
    }

@span(name="fraud_detection_llm_call")
def perform_fraud_check(order_id: str, customer_details: dict):
    print(f"Performing fraud check for order {order_id}...")
    # Input/output and LLM usage will be automatically captured
    result = analyze_for_fraud({"order": order_id, "customer": customer_details})
    print(f"Fraud check result: {result.get('assessment')}")
    return result

@trace(name="process_customer_order", customer_tier="silver")
def process_order_v2(order_id: str, items: list, customer_info: dict):
    print(f"V2 Processing order {order_id} for customer {customer_info.get('id')}")
    
    # This call will create a span under the "process_customer_order" trace
    inventory_status = check_inventory(items)
    
    # Another span under the same trace
    fraud_assessment = perform_fraud_check(order_id, customer_info)
    
    if all(inventory_status.values()) and fraud_assessment.get("fraud_score", 1) < 0.5:
        print(f"Order {order_id} V2 processed successfully.")
        return {"status": "success", "order_id": order_id, "fraud_check": fraud_assessment.get("assessment")}
    else:
        print(f"Order {order_id} V2 processing failed or held.")
        return {"status": "failed_or_held", "inventory": inventory_status, "fraud_check": fraud_assessment.get("assessment")}

customer = {"id": "cust789", "history_score": 5}
process_order_v2("ORD67890", [{"item_id": "C3", "qty": 1}], customer)
```
