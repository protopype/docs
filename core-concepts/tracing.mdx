---
title: 'Tracing with Agensight'
description: 'Learn how to use Agensight for tracing and observability in your Python applications.'
---

# Agensight Tracing

The `agensight.tracing` module provides a powerful way to instrument your Python applications for observability. By adding traces and spans, you can gain insights into your code's execution flow, monitor performance, and debug issues more effectively. This system is built on the foundations of OpenTelemetry, a widely adopted open-standard for observability.

## Key Concepts

*   **Trace**: Represents the entire lifecycle of a request or an operation as it moves through your system or within a single process. A trace is a collection of spans.
*   **Span**: Represents a single unit of work or operation within a trace. Spans can be nested to represent parent-child relationships between operations. For example, an incoming API request might be a trace, and operations like "database query," "external API call," or "data transformation" within that request would be individual spans.
*   **Exporter**: A component that sends your trace data to a backend system for storage, visualization, and analysis (e.g., console, a local database, Jaeger, Zipkin, OpenTelemetry Collector).
*   **Attributes**: Key-value pairs attached to traces or spans that provide additional context about the operation (e.g., user ID, HTTP method, function arguments, LLM model name).

## Setup and Initialization

Before you can create traces or spans, the Agensight tracing system needs to be initialized. This is typically done once at the beginning of your application's lifecycle.

**Relevant File:** `agensight/tracing/setup.py`

### `setup_tracing(service_name="default", exporter_type=None)`

This is the primary function for initializing the tracing system.

*   **`service_name` (str, optional)**: A descriptive name for your application or service (e.g., "user-api", "data-processing-pipeline"). This name helps identify where traces originate. Defaults to `"default"`.
*   **`exporter_type` (str, optional)**: Determines where the collected trace data will be sent.
    *   If `None` (default): Agensight checks the `TRACE_EXPORTER` environment variable. If this variable is not set, it defaults to `"console"`, which prints trace information directly to your standard output. This is useful for local development and debugging.
    *   `"db"`: Traces are stored in a local SQLite database named `traces.db` (created in the directory where your application runs). The schema is managed by `agensight/tracing/db.py`, and the export logic is in `agensight/tracing/exporter_db.py`.
    *   Other values (e.g., `"otlp"`, `"zipkin"`, `"jaeger"`): Agensight can be configured to use other standard OpenTelemetry exporters. The available exporters are defined in `agensight/tracing/exporters.py`.

**Initialization Steps:**

1.  **Exporter Configuration**: An exporter instance is created based on `exporter_type`.
2.  **Database Initialization (for "db" exporter)**: If `exporter_type` is `"db"`, the `init_schema()` function from `agensight/tracing/db.py` is called to ensure the necessary tables exist in `traces.db`.
3.  **TracerProvider Setup**: An OpenTelemetry `TracerProvider` is configured.
4.  **Span Processors**:
    *   `BatchSpanProcessor`: Bundles spans together before sending them to the exporter, improving efficiency.
    *   `TokenPropagator` (from `agensight/tracing/token_propagator.py`): A custom span processor specific to Agensight, likely for handling custom token or context propagation logic.
5.  **Global Registration**: The configured `TracerProvider` is set globally using `opentelemetry.trace.set_tracer_provider(provider)`.

**Usage Example:**

```python
# main.py or app.py
from agensight.tracing import setup_tracing
import os

# Option 1: Configure via environment variable
# Set TRACE_EXPORTER=db in your environment
# setup_tracing(service_name="my-awesome-app")

# Option 2: Explicitly set exporter type
setup_tracing(service_name="my-awesome-app", exporter_type="console")

# Option 3: Using the database exporter
# setup_tracing(service_name="data-pipeline-service", exporter_type="db")


```text
## Creating Traces with `@trace`

The `@trace` decorator is the primary way to define the boundaries of a significant operation or a request flow. Applying it to a function means that every call to that function will initiate a new trace.

**Relevant File:** `agensight/tracing/decorators.py`

### `@trace(name: Optional[str] = None, **default_attributes)`

This decorator wraps a function, instrumenting it to create a trace each time it's executed.

*   **`name` (str, optional)**: A custom name for the trace. If not provided (`None`), the name of the decorated function (`func.__name__`) will be used.
*   **`**default_attributes` (dict, optional)**: A set of key-value pairs that will be stored as metadata for the trace. This is particularly relevant if you're using the `"db"` exporter, as these attributes are saved in the `metadata` column of the `traces` table.

**Decorator Behavior:**

1.  **Trace Naming**: Determines the `trace_name`.
2.  **ID Generation**: Generates a unique `trace_id` (a UUID string).
3.  **Context Propagation**: Stores `trace_id` and `trace_name` in context variables (`current_trace_id`, `current_trace_name` from `agensight.tracing.context`). This allows nested `@span` decorators to associate themselves with this parent trace.
4.  **Execution & Timing**: Executes the wrapped function and records its start and end times.
5.  **Data Persistence (for "db" exporter)**:
    *   Retrieves the session ID using `get_session_id()` (if sessions are enabled via `is_session_enabled()` from `agensight.tracing.session`).
    *   Inserts a record into the `traces` table in `traces.db` with the `trace_id`, `trace_name`, `started_at`, `ended_at`, `session_id`, and serialized `default_attributes`.
6.  **Context Cleanup**: Clears any input/output context that might have been set by inner spans (`trace_input.set(None)`, `trace_output.set(None)`).

**Usage Example:**

```python
from agensight.tracing import trace, setup_tracing, span # span for later

setup_tracing(service_name="user-service", exporter_type="console")

@trace(name="process_new_user_signup", department="onboarding")
def handle_new_user(username: str, email: str):
    print(f"Starting signup for {username}...")
    # Simulate some work
    create_user_record(username, email)
    send_welcome_email(email)
    print(f"Signup complete for {username}.")
    return {"user_id": f"uuid_{username}", "status": "created"}

# Example of a function that might be called internally, creating a span
@span(name="db_create_user") # This will be part of the 'process_new_user_signup' trace
def create_user_record(username, email):
    print(f"Creating DB record for {username}")
    # import time
    # time.sleep(0.1) # Simulate DB work
    pass

@span(name="email_send_welcome") # Also part of the 'process_new_user_signup' trace
def send_welcome_email(email_address):
    print(f"Sending welcome email to {email_address}")
    # import time
    # time.sleep(0.05) # Simulate email sending
    pass

handle_new_user("john.doe", "john.doe@example.com")


```text
## Creating Spans with `@span`

Spans offer a more granular view of work done *within* a trace. They are used to instrument specific operations or logical blocks of code inside a function that is already part of a trace (i.e., decorated with `@trace` or called by such a function).

**Relevant File:** `agensight/tracing/decorators.py`

### `@span(name: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None, input: Optional[Any] = None, output: Optional[Any] = None)`

This decorator wraps a function to create an OpenTelemetry span each time it's called. It **must** be used within the context of an active trace (i.e., a function decorated with `@trace` must be higher up in the call stack).

*   **`name` (str, optional)**: A custom name for the span. If `None`, the decorated function's name (`func.__name__`) is used.
*   **`metadata` (Dict[str, Any], optional)**: A dictionary of custom key-value attributes to attach to this span. These attributes provide rich contextual information.
*   **`input` (Any, optional)**: Allows you to explicitly specify the input data for this operation. If provided, this will be captured as part of the span's attributes.
*   **`output` (Any, optional)**: Allows you to explicitly specify the output data from this operation. If provided, this will be captured.

**Decorator Behavior:**

1.  **Tracer Acquisition**: Gets an OpenTelemetry tracer instance (named "default" via `opentelemetry.trace.get_tracer("default")`).
2.  **Span Naming**: Determines the `span_name`.
3.  **Attribute Initialization**: Initializes span attributes with a copy of `metadata` (if provided).
4.  **Trace Linkage**:
    *   Retrieves `current_trace_id` and `current_trace_name` from the context variables (set by the parent `@trace`).
    *   Adds these as `trace_id` and `trace.name` attributes to the span, linking it to the parent trace.
5.  **Session Linkage**: If a session is active (via `is_session_enabled()` from `agensight.tracing.session`), the `session.id` is added as an attribute.
6.  **Span Lifecycle**:
    *   Starts a new OpenTelemetry span using `tracer.start_as_current_span(span_name, attributes=attributes)`. This makes the new span the "current" span in the context.
    *   Executes the wrapped function.
7.  **Input/Output Capture**:
    *   **Input**:
        *   It first checks if `trace_input` (from `agensight.tracing.context`) has been set (perhaps by a nested operation).
        *   If not, it uses the `input` argument provided to `@span`.
        *   If that's also not available, it defaults to the function's `*args` or `**kwargs` as a fallback.
    *   **Output**:
        *   It uses the `output` argument provided to `@span`.
        *   If not available, it defaults to the `result` returned by the wrapped function.
    *   The captured input and output are then processed by `normalize_input_output`. This function attempts to stringify the data safely and structures it into a `{"prompts": [...], "completions": [...]}` format, which is then stored as a JSON string in the `gen_ai.normalized_input_output` span attribute. This suggests a focus on tracing interactions, possibly with LLMs or similar request/response systems.
8.  **Error Handling**: If the wrapped function raises an exception:
    *   The span's status is set to `Status(StatusCode.ERROR, str(e))`.
    *   The (partially) captured input/output data is still recorded.
    *   The exception is re-raised.
9.  **LLM Usage Extraction (GenAI specific)**:
    *   Calls `_extract_usage_from_result(result)` to attempt to find token usage information (e.g., `total_tokens`, `prompt_tokens`, `completion_tokens`) if the function's `result` object has a `.usage` attribute (which could be an object or a dict) or if `result` itself is a dict containing a `usage` key.
    *   If usage data is found, it's added as specific span attributes (e.g., `llm.usage.total_tokens`, `gen_ai.usage.prompt_tokens`).
10. **Span End**: The span automatically ends when the `with tracer.start_as_current_span(...)` 


**Usage Example (within a traced function):**

```python
from agensight.tracing import trace, span, setup_tracing
import time
# from opentelemetry import trace as ot_trace # For getting current span if needed

# Assume setup_tracing has been called as in previous examples
setup_tracing(service_name="llm-wrapper", exporter_type="console")

# A simulated function that might call an LLM
def query_llm_service(prompt: str, model_name: str) -> dict:
    print(f"Querying LLM ({model_name}) with: '{prompt[:30]}...'")
    time.sleep(0.2) # Simulate network latency
    # Simulated response with usage data
    response_text = f"Response from {model_name} for prompt: {prompt}"
    prompt_tokens = len(prompt.split())
    completion_tokens = len(response_text.split())
    return {
        "text": response_text,
        "usage": {
            "prompt_tokens": prompt_tokens,
            "completion_tokens": completion_tokens,
            "total_tokens": prompt_tokens + completion_tokens
        },
        "model_used": model_name
    }

@trace(name="article_generation_pipeline")
def generate_article(topic: str):
    print(f"Generating article for topic: {topic}")

    @span(name="brainstorm_ideas", metadata={"creativity_level": "high"})
    def brainstorm(current_topic: str):
        # Explicitly setting input for clarity, though args would also work
        # span_input = {"topic": current_topic} # Could be passed to @span(input=...)
        print(f"Brainstorming for: {current_topic}")
        time.sleep(0.1)
        return [f"Idea 1 for {current_topic}", f"Idea 2 for {current_topic}"]

    @span(name="draft_section", metadata={"llm_temperature": 0.7})
    def draft(section_idea: str, llm_model: str):
        prompt = f"Write a draft for the section: {section_idea}"
        # Output will be automatically captured from the return value.
        # Input is automatically captured from args.
        # LLM usage will be extracted from the return dict.
        return query_llm_service(prompt, model_name=llm_model)

    ideas = brainstorm(topic)
    
    full_article_parts = []
    for i, idea in enumerate(ideas):
        section_result = draft(idea, llm_model="text-davinci-003" if i % 2 == 0 else "gpt-4o-mini")
        full_article_parts.append(section_result["text"])
        # Access span attributes if needed, though usually handled by exporter
        # current_span = ot_trace.get_current_span()
        # print(f"Draft span attributes: {current_span.attributes}")

    return "\\n\\n".join(full_article_parts)

# Run the pipeline
article_content = generate_article("The Future of AI in Software Development")
# print(f"\nGenerated Article:\n{article_content}")


```text
## Summary of Core Tracing Files

*   **`agensight/tracing/setup.py`**:
    *   Contains `setup_tracing` for global tracer initialization.
    *   Configures exporters (console, database, OTLP, etc.).
*   **`agensight/tracing/decorators.py`**:
    *   Defines the user-facing `@trace` decorator for initiating traces.
    *   Defines the user-facing `@span` decorator for creating detailed spans within traces.
*   **`agensight/tracing/tracer.py`**:
    *   Provides utility functions like `get_tracer` (to obtain an OpenTelemetry `Tracer` instance) and `start_span` (a more direct, lower-level way to create spans, potentially used internally by the decorators or for advanced custom instrumentation).
*   **`agensight/tracing/exporters.py` & `agensight/tracing/exporter_db.py`**:
    *   `exporters.py`: Defines a factory function `get_exporter` to instantiate different types of OpenTelemetry span exporters.
    *   `exporter_db.py`: Implements the `DBSpanExporter`, which writes span data to the SQLite `traces.db` database, including logic for serializing attributes and handling trace relationships.
*   **`agensight/tracing/db.py`**:
    *   Manages the SQLite database (`traces.db`) schema creation (`init_schema`) and provides a connection utility (`get_db`). It defines tables like `traces` (for top-level trace information) and uses OpenTelemetry's standard span attributes for detailed span data when the `DBSpanExporter` is active.
*   **`agensight/tracing/context.py`**:
    *   Uses `contextvars` to manage trace-specific context (like `current_trace_id`, `current_trace_name`, `trace_input`, `trace_output`) across asynchronous tasks and different parts of the code within a single trace.
*   **`agensight/tracing/session.py`**:
    *   Provides utilities (`is_session_enabled`, `get_session_id`) to manage and associate traces/spans with a broader "session" concept, if used by the application.

By using `@trace` for high-level operations and `@span` for the constituent parts, you can build a comprehensive and detailed observability layer for your Agensight applications.

